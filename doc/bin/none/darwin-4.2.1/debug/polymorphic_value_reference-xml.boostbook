<?xml version="1.0" standalone="yes"?>
<library-reference id="polymorphic_value_reference"><title>polymorphic_value_reference</title><header name="boost/polymorphic_value.hpp">
<namespace name="boost">
<class name="bad_polymorphic_value_construction"><inherit access="private">exception</inherit><method-group name="public member functions">
<method name="what" cv="const noexcept"><type>const char *</type></method>
</method-group>
<constructor/>
</class><struct name="default_copy"><template>
      <template-type-parameter name="T"/>
    </template><method-group name="public member functions">
<method name="operator()" cv="const"><type>T *</type><parameter name="t"><paramtype>const T &amp;</paramtype></parameter></method>
</method-group>
</struct><struct name="default_delete"><template>
      <template-type-parameter name="T"/>
    </template><method-group name="public member functions">
<method name="operator()" cv="const"><type>void</type><parameter name="t"><paramtype>const T *</paramtype></parameter></method>
</method-group>
</struct><class name="polymorphic_value"><template>
      <template-type-parameter name="cT"/>
    </template><method-group name="public member functions">
<method name="swap" cv="noexcept"><type>void</type><parameter name="p"><paramtype><classname>polymorphic_value</classname> &amp;</paramtype></parameter></method>
<method name="conversion-operator" cv="const" specifiers="explicit"><type>bool</type><description><para>returns true if there is a managed object, otherwise returns false. </para></description></method>
<method name="operator-&gt;" cv="const"><type>const T *</type><description><para>requires a managed object. </para></description></method>
<method name="value" cv="const"><type>const T &amp;</type><description><para>requires a managed object. </para></description></method>
<method name="operator*" cv="const"><type>const T &amp;</type><description><para>requires a managed object. </para></description></method>
<method name="operator-&gt;"><type>T *</type><description><para>requires a managed object. </para></description></method>
<method name="value"><type>T &amp;</type><description><para>requires a managed object. </para></description></method>
<method name="operator*"><type>T &amp;</type><description><para>requires a managed object. </para></description></method>
</method-group>
<destructor/>
<constructor/>
<constructor specifiers="explicit"><template>
          <template-type-parameter name="U"/>
          <template-type-parameter name="C"><default><classname alt="boost::default_copy">default_copy</classname>&lt;U&gt;</default></template-type-parameter>
          <template-type-parameter name="D"><default><classname alt="boost::default_delete">default_delete</classname>&lt;U&gt;</default></template-type-parameter>
        </template><parameter name="u"><paramtype>U *</paramtype></parameter><parameter name="copier"><paramtype>C</paramtype><default>C{}</default></parameter><parameter name="deleter"><paramtype>D</paramtype><default>D{}</default></parameter><description><para>requires <computeroutput>U*</computeroutput> is convertible to <computeroutput>T*</computeroutput>. If <computeroutput>C</computeroutput> is <computeroutput><classname alt="boost::default_copy">default_copy</classname>&lt;U&gt;</computeroutput> and <computeroutput>D</computeroutput> is <computeroutput><classname alt="boost::default_delete">default_delete</classname>&lt;U&gt;</computeroutput>, requires <computeroutput>typeid(*u) == typeid(U)</computeroutput>. </para></description></constructor>
<constructor><parameter name="p"><paramtype>const <classname>polymorphic_value</classname> &amp;</paramtype></parameter></constructor>
<constructor><template>
          <template-type-parameter name="U"/>
        </template><parameter name="p"><paramtype>const <classname>polymorphic_value</classname>&lt; U &gt; &amp;</paramtype></parameter><description><para>requires <computeroutput>T</computeroutput> and <computeroutput>U</computeroutput> are different types, <computeroutput>std::remove_const_t&lt;U&gt;*</computeroutput> is convertible to <computeroutput>T*</computeroutput>. </para></description></constructor>
<constructor cv="noexcept"><parameter name="p"><paramtype><classname>polymorphic_value</classname> &amp;&amp;</paramtype></parameter></constructor>
<constructor><template>
          <template-type-parameter name="U"/>
        </template><parameter name="p"><paramtype><classname>polymorphic_value</classname>&lt; U &gt; &amp;&amp;</paramtype></parameter><description><para>requires <computeroutput>T</computeroutput> and <computeroutput>U</computeroutput> are different types, <computeroutput>U*</computeroutput> is convertible to <computeroutput>T*</computeroutput>. </para></description></constructor>
<constructor><template>
          <template-type-parameter name="U"/>
        </template><parameter name="u"><paramtype>U &amp;&amp;</paramtype></parameter><description><para>requires <computeroutput>std::decay_t&lt;U&gt;</computeroutput> is not a <computeroutput><classname alt="boost::polymorphic_value">polymorphic_value</classname></computeroutput>, <computeroutput>std::decay_t&lt;U&gt;*</computeroutput> is convertible to <computeroutput>T*</computeroutput>. </para></description></constructor>
<copy-assignment><type><classname>polymorphic_value</classname> &amp;</type><parameter name="p"><paramtype>const <classname>polymorphic_value</classname> &amp;</paramtype></parameter></copy-assignment>
<copy-assignment><type><classname>polymorphic_value</classname> &amp;</type><template>
          <template-type-parameter name="U"/>
        </template><parameter name="p"><paramtype>const <classname>polymorphic_value</classname>&lt; U &gt; &amp;</paramtype></parameter><description><para>requires <computeroutput>T</computeroutput> and <computeroutput>U</computeroutput> are different types, <computeroutput>U*</computeroutput> is convertible to <computeroutput>T*</computeroutput>. </para></description></copy-assignment>
<copy-assignment cv="noexcept"><type><classname>polymorphic_value</classname> &amp;</type><parameter name="p"><paramtype><classname>polymorphic_value</classname> &amp;&amp;</paramtype></parameter></copy-assignment>
<copy-assignment><type><classname>polymorphic_value</classname> &amp;</type><template>
          <template-type-parameter name="U"/>
        </template><parameter name="p"><paramtype><classname>polymorphic_value</classname>&lt; U &gt; &amp;&amp;</paramtype></parameter><description><para>requires <computeroutput>T</computeroutput> and <computeroutput>U</computeroutput> are different types, <computeroutput>U*</computeroutput> is convertible to <computeroutput>T*</computeroutput>. </para></description></copy-assignment>
<copy-assignment><type><classname>polymorphic_value</classname> &amp;</type><template>
          <template-type-parameter name="U"/>
        </template><parameter name="u"><paramtype>U &amp;&amp;</paramtype></parameter><description><para>requires <computeroutput>std::decay_t&lt;U&gt;</computeroutput> is not a <computeroutput><classname alt="boost::polymorphic_value">polymorphic_value</classname></computeroutput>, <computeroutput>std::decay_t&lt;U&gt;*</computeroutput> is convertible to <computeroutput>T*</computeroutput>. </para></description></copy-assignment>
</class><function name="make_polymorphic_value"><type><classname>polymorphic_value</classname>&lt; T &gt;</type><template>
          <template-type-parameter name="T"/>
          <template-nontype-parameter name="Ts"><type>class...</type></template-nontype-parameter>
        </template><parameter name="ts"><paramtype>Ts &amp;&amp;...</paramtype></parameter></function>
<function name="swap"><type>void</type><template>
          <template-type-parameter name="T"/>
        </template><parameter name="t"><paramtype><classname>polymorphic_value</classname>&lt; T &gt; &amp;</paramtype></parameter><parameter name="u"><paramtype><classname>polymorphic_value</classname>&lt; T &gt; &amp;</paramtype></parameter></function>
</namespace>
</header>
</library-reference>