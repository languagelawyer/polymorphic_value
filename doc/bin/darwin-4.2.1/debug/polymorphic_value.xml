<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE library PUBLIC "-//Boost//DTD BoostBook XML V1.0//EN" "http://www.boost.org/tools/boostbook/dtd/boostbook.dtd">
<library id="polymorphic_value" name="Boost.PolymorphicValue (Proposed)" dirname="polymorphic_value"
last-revision="$Date: 2018/06/21 07:45:53 $" xmlns:xi="http://www.w3.org/2001/XInclude">
  <libraryinfo>
    <authorgroup>
    <author>
      <firstname>Jonathan</firstname> <surname>Coe</surname>
    </author>
    </authorgroup>
    <copyright>
      <year>2017</year> <holder>Jonathan Coe</holder>
    </copyright>
    <legalnotice id="polymorphic_value.legal">
      <para>
        Distributed under the Boost Software License, Version 1.0. (See accompanying
        file LICENSE_1_0.txt or copy at <ulink url="http://www.boost.org/LICENSE_1_0.txt">http://www.boost.org/LICENSE_1_0.txt</ulink>)
      </para>
    </legalnotice>
    <librarypurpose>
      A polymorphic value-type for C++ targeting standardization.
    </librarypurpose>
    <librarycategory name="category:template"></librarycategory>
  </libraryinfo>
  <title>Boost.PolymorphicValue (Proposed)</title>
  <section id="boost_polymorphicvalue__proposed_.introduction">
    <title><link linkend="boost_polymorphicvalue__proposed_.introduction">Introduction</link></title>
    <para>
      Class template <code><phrase role="identifier">polymorphic_value</phrase></code>
      represents a polymorphic object with value-semantics.
    </para>
    <bridgehead renderas="sect3" id="boost_polymorphicvalue__proposed_.introduction.h0">
      <phrase id="boost_polymorphicvalue__proposed_.introduction.problem"/><link
      linkend="boost_polymorphicvalue__proposed_.introduction.problem">Problem</link>
    </bridgehead>
    <para>
      Suppose we want to design a class in terms of polymorphic components and have
      the compiler correctly generate the special member functions: destructor, copy
      constructor, copy assignment operator, move constructor and move assignment
      operator.
    </para>
    <bridgehead renderas="sect3" id="boost_polymorphicvalue__proposed_.introduction.h1">
      <phrase id="boost_polymorphicvalue__proposed_.introduction.solution"/><link
      linkend="boost_polymorphicvalue__proposed_.introduction.solution">Solution</link>
    </bridgehead>
    <para>
      This is how one would write a class made of polymorphic components using <code><phrase
      role="identifier">polymorphic_value</phrase></code>:
    </para>
<programlisting><phrase role="preprocessor">#include</phrase> <phrase role="special">&lt;</phrase><phrase role="identifier">boost</phrase><phrase role="special">/</phrase><phrase role="identifier">polymorphic_value</phrase><phrase role="special">.</phrase><phrase role="identifier">hpp</phrase><phrase role="special">&gt;</phrase>
<phrase role="preprocessor">#include</phrase> <phrase role="special">&lt;</phrase><phrase role="identifier">vector</phrase><phrase role="special">&gt;</phrase>

<phrase role="keyword">class</phrase> <phrase role="identifier">Zoo</phrase> <phrase role="special">{</phrase>
  <phrase role="identifier">std</phrase><phrase role="special">::</phrase><phrase role="identifier">vector</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">boost</phrase><phrase role="special">::</phrase><phrase role="identifier">polymorphic_value</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">Animal</phrase><phrase role="special">&gt;&gt;</phrase> <phrase role="identifier">animals_</phrase><phrase role="special">;</phrase>
 <phrase role="keyword">public</phrase><phrase role="special">:</phrase>
  <phrase role="identifier">Zoo</phrase><phrase role="special">()</phrase> <phrase role="special">=</phrase> <phrase role="keyword">default</phrase><phrase role="special">;</phrase>
  <phrase role="identifier">Zoo</phrase><phrase role="special">(</phrase><phrase role="identifier">std</phrase><phrase role="special">::</phrase><phrase role="identifier">vector</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">boost</phrase><phrase role="special">::</phrase><phrase role="identifier">polymorphic_value</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">Animal</phrase><phrase role="special">&gt;&gt;</phrase> <phrase role="identifier">animals</phrase><phrase role="special">)</phrase> <phrase role="special">:</phrase>
      <phrase role="identifier">animals_</phrase><phrase role="special">(</phrase><phrase role="identifier">std</phrase><phrase role="special">::</phrase><phrase role="identifier">move</phrase><phrase role="special">(</phrase><phrase role="identifier">animals</phrase><phrase role="special">))</phrase> <phrase role="special">{}</phrase>

  <phrase role="identifier">std</phrase><phrase role="special">::</phrase><phrase role="identifier">size_t</phrase> <phrase role="identifier">size</phrase><phrase role="special">()</phrase> <phrase role="keyword">const</phrase> <phrase role="special">{</phrase>
    <phrase role="keyword">return</phrase> <phrase role="identifier">animals_</phrase><phrase role="special">.</phrase><phrase role="identifier">size</phrase><phrase role="special">();</phrase>
  <phrase role="special">}</phrase>

  <phrase role="keyword">const</phrase> <phrase role="identifier">Animal</phrase><phrase role="special">&amp;</phrase> <phrase role="keyword">operator</phrase><phrase role="special">[](</phrase><phrase role="identifier">std</phrase><phrase role="special">::</phrase><phrase role="identifier">size_t</phrase> <phrase role="identifier">i</phrase><phrase role="special">)</phrase> <phrase role="keyword">const</phrase> <phrase role="special">{</phrase>
    <phrase role="keyword">return</phrase> <phrase role="special">*</phrase><phrase role="identifier">animals_</phrase><phrase role="special">[</phrase><phrase role="identifier">i</phrase><phrase role="special">];</phrase>
  <phrase role="special">}</phrase>

  <phrase role="identifier">Animal</phrase><phrase role="special">&amp;</phrase> <phrase role="keyword">operator</phrase><phrase role="special">[](</phrase><phrase role="identifier">std</phrase><phrase role="special">::</phrase><phrase role="identifier">size_t</phrase> <phrase role="identifier">i</phrase><phrase role="special">)</phrase> <phrase role="special">{</phrase>
    <phrase role="keyword">return</phrase> <phrase role="special">*</phrase><phrase role="identifier">animals_</phrase><phrase role="special">[</phrase><phrase role="identifier">i</phrase><phrase role="special">];</phrase>
  <phrase role="special">}</phrase>

  <phrase role="keyword">void</phrase> <phrase role="identifier">AddAnimal</phrase><phrase role="special">(</phrase><phrase role="identifier">boost</phrase><phrase role="special">::</phrase><phrase role="identifier">polymorphic_value</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">Animal</phrase><phrase role="special">&gt;</phrase> <phrase role="identifier">animal</phrase><phrase role="special">)</phrase> <phrase role="special">{</phrase>
    <phrase role="identifier">animals_</phrase><phrase role="special">.</phrase><phrase role="identifier">push_back</phrase><phrase role="special">(</phrase><phrase role="identifier">std</phrase><phrase role="special">::</phrase><phrase role="identifier">move</phrase><phrase role="special">(</phrase><phrase role="identifier">animal</phrase><phrase role="special">));</phrase>
  <phrase role="special">}</phrase>
<phrase role="special">}</phrase>
</programlisting>
  </section>
  <section id="boost_polymorphicvalue__proposed_.tutorial">
    <title><link linkend="boost_polymorphicvalue__proposed_.tutorial">Tutorial</link></title>
    <section id="boost_polymorphicvalue__proposed_.tutorial.motivation">
      <title><link linkend="boost_polymorphicvalue__proposed_.tutorial.motivation">Motivation</link></title>
      <para>
        Object-oriented programming allows objects to be composed of other objects.
        A class heirarchy of <code><phrase role="identifier">Shape</phrase></code>s
        might lead to a <code><phrase role="identifier">Picture</phrase></code> class
        being a collection of <code><phrase role="identifier">Shape</phrase></code>s
        and their respective positions.
      </para>
      <para>
        When components are stored as values, the compiler is able to generate special
        member functions: destructor, copy constructor, copy assignment operator,
        move constructor and move assignment operator.
      </para>
      <para>
        Storing components as values means that the type of the component must be
        known at compile time. For cases when components are base classes from an
        inheritance heirarchy - like <code><phrase role="identifier">Shape</phrase></code>s
        in a <code><phrase role="identifier">Picture</phrase></code> - we are unable
        to store components as values and will have to implement special member functions
        ourselves.
      </para>
      <para>
        <code><phrase role="identifier">polymorphic_value</phrase></code> is a class
        template that imparts value semantics to a polymorphic object. Use of it
        allows design of a composite object in terms of abstract or base class objects
        without the need to implement (and maintain) special member functions.
      </para>
<programlisting><phrase role="keyword">class</phrase> <phrase role="identifier">Shape</phrase><phrase role="special">;</phrase>
<phrase role="keyword">class</phrase> <phrase role="identifier">Picture</phrase> <phrase role="special">{</phrase>
  <phrase role="identifier">std</phrase><phrase role="special">::</phrase><phrase role="identifier">vector</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">boost</phrase><phrase role="special">::</phrase><phrase role="identifier">polymorphic_value</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">Shape</phrase><phrase role="special">&gt;&gt;</phrase> <phrase role="identifier">components_</phrase><phrase role="special">;</phrase>
  <phrase role="comment">// ...</phrase>
<phrase role="special">};</phrase>
</programlisting>
    </section>
    <section id="boost_polymorphicvalue__proposed_.tutorial.design_overview">
      <title><link linkend="boost_polymorphicvalue__proposed_.tutorial.design_overview">Design
      Overview</link></title>
      <para>
        A <code><phrase role="identifier">polymorphic_value</phrase></code> member
        can be used with the same syntax one would use for a pointer member: <code><phrase
        role="keyword">operator</phrase><phrase role="special">-&gt;</phrase></code>
        and <code><phrase role="keyword">operator</phrase><phrase role="special">*</phrase></code>
        will respectively return a pointer and a reference. Like a pointer, <code><phrase
        role="identifier">polymorphic_value</phrase></code> can be null so should
        probably be initialised within the parent object constructor.
      </para>
      <para>
        <code><phrase role="identifier">polymorphic_value</phrase></code> has value
        semantics: when copied, it will perform a deep copy of the owned object,
        and it propagates <code><phrase role="keyword">const</phrase></code> to the
        owned object.
      </para>
      <bridgehead renderas="sect4" id="boost_polymorphicvalue__proposed_.tutorial.design_overview.h0">
        <phrase id="boost_polymorphicvalue__proposed_.tutorial.design_overview.deep_copies"/><link
        linkend="boost_polymorphicvalue__proposed_.tutorial.design_overview.deep_copies">Deep
        copies</link>
      </bridgehead>
      <para>
        <code><phrase role="identifier">polymorphic_value</phrase></code> enables
        deep-copies through inheritance heirarchies: a <code><phrase role="identifier">polymorphic_value</phrase><phrase
        role="special">&lt;</phrase><phrase role="identifier">Shape</phrase><phrase
        role="special">&gt;</phrase></code> initialized with a <code><phrase role="identifier">Circle</phrase></code>
        object will produce a <code><phrase role="identifier">polymorphic_value</phrase><phrase
        role="special">&lt;</phrase><phrase role="identifier">Shape</phrase><phrase
        role="special">&gt;</phrase></code> managing a copy of the <code><phrase
        role="identifier">Circle</phrase></code> object produced using <code><phrase
        role="identifier">Circle</phrase></code>'s copy constructor.
      </para>
      <para>
        Virtual destructors can be used to ensure that a derived class object is
        correctly destroyed through a base class pointer. C++ offers no equivalent
        of virtual destructors for copy construction; <code><phrase role="identifier">polymorphic_value</phrase></code>
        uses type-erasure to store type information about the managed object and
        call the copy constructor when required. Note that virtual destructors are
        not needed for <code><phrase role="identifier">polymorphic_value</phrase></code>
        as the type-erasure mechanism used to produce copies is also used to call
        the correct derived class destructor.
      </para>
      <bridgehead renderas="sect4" id="boost_polymorphicvalue__proposed_.tutorial.design_overview.h1">
        <phrase id="boost_polymorphicvalue__proposed_.tutorial.design_overview.const_propagation"/><link
        linkend="boost_polymorphicvalue__proposed_.tutorial.design_overview.const_propagation">Const-propagation</link>
      </bridgehead>
      <para>
        As <code><phrase role="identifier">polymorphic_value</phrase></code> is intended
        to be used to model a value-type, a <code><phrase role="keyword">const</phrase></code>
        <code><phrase role="identifier">polymorphic_value</phrase><phrase role="special">&lt;</phrase><phrase
        role="identifier">T</phrase><phrase role="special">&gt;</phrase></code> will
        only give access to a <code><phrase role="keyword">const</phrase> <phrase
        role="identifier">T</phrase><phrase role="special">&amp;</phrase></code>
        and <code><phrase role="keyword">const</phrase> <phrase role="identifier">T</phrase><phrase
        role="special">*</phrase></code>. For non-<code><phrase role="keyword">const</phrase></code>
        access, a non-<code><phrase role="keyword">const</phrase></code> <code><phrase
        role="identifier">polymorphic_value</phrase><phrase role="special">&lt;</phrase><phrase
        role="identifier">T</phrase><phrase role="special">&gt;</phrase></code> is
        needed.
      </para>
      <para>
        For design of component-based objects, const-propagation is required as no
        part of a contextually immutable object should be mutable. Where access to
        a mutable <code><phrase role="identifier">polymorphic_value</phrase><phrase
        role="special">&lt;</phrase><phrase role="identifier">T</phrase><phrase role="special">&gt;</phrase></code>
        is truly required from a <code><phrase role="keyword">const</phrase></code>
        access path, a <code><phrase role="keyword">mutable</phrase> <phrase role="identifier">polymorphic_value</phrase><phrase
        role="special">&lt;</phrase><phrase role="identifier">T</phrase><phrase role="special">&gt;</phrase></code>
        member can be used (this should be rare).
      </para>
      <bridgehead renderas="sect4" id="boost_polymorphicvalue__proposed_.tutorial.design_overview.h2">
        <phrase id="boost_polymorphicvalue__proposed_.tutorial.design_overview.default_construction_and_a_null_state"/><link
        linkend="boost_polymorphicvalue__proposed_.tutorial.design_overview.default_construction_and_a_null_state">Default
        construction and a null state</link>
      </bridgehead>
      <para>
        <code><phrase role="identifier">polymorphic_value</phrase></code> is intended
        to be used with Standard Library collections which requires that it is default
        constructible. As <code><phrase role="identifier">polymorphic_value</phrase><phrase
        role="special">&lt;</phrase><phrase role="identifier">T</phrase><phrase role="special">&gt;</phrase></code>
        can be instantiated for an abstract class <code><phrase role="identifier">T</phrase></code>,
        the default constructor cannot, in general, default construct the managed
        object. There may also be cases where default construction of the managed
        object would be undesirably expensive in terms of memory or speed.
      </para>
      <para>
        The default constructor puts <code><phrase role="identifier">polymorphic_value</phrase></code>
        in an empty state where no object is managed. Both <code><phrase role="keyword">operator</phrase><phrase
        role="special">-&gt;</phrase></code> and <code><phrase role="keyword">operator</phrase><phrase
        role="special">*</phrase></code> have preconditions where calling them on
        an empty <code><phrase role="identifier">polymorphic_value</phrase></code>
        is prohibited. An <code><phrase role="keyword">explicit</phrase></code>
        <code><phrase role="keyword">operator</phrase> <phrase role="keyword">bool</phrase></code>
        is provided to allow idiomatic checking for a null state.
      </para>
      <bridgehead renderas="sect4" id="boost_polymorphicvalue__proposed_.tutorial.design_overview.h3">
        <phrase id="boost_polymorphicvalue__proposed_.tutorial.design_overview.reference_stability"/><link
        linkend="boost_polymorphicvalue__proposed_.tutorial.design_overview.reference_stability">Reference
        stability</link>
      </bridgehead>
      <para>
        <code><phrase role="identifier">polymorphic_value</phrase></code> makes no
        guarantees of the stability of pointers and references obtained from <code><phrase
        role="keyword">operator</phrase><phrase role="special">-&gt;</phrase></code>
        and <code><phrase role="keyword">operator</phrase><phrase role="special">*</phrase></code>.
        <code><phrase role="identifier">polymorphic_value</phrase></code> models
        a value-type like optional or variant and may make use of a small object
        optimization to avoid heap allocation for small objects. Such an optimisation
        would render pointers and references to a managed object invalid after a
        move operation. The result of <code><phrase role="keyword">operator</phrase><phrase
        role="special">-&gt;</phrase></code> and <code><phrase role="keyword">operator</phrase><phrase
        role="special">*</phrase></code> should be used directly, not cached for
        later use.
      </para>
<programlisting><phrase role="comment">// recommended use</phrase>
<phrase role="identifier">polymorphic_value</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">Shape</phrase><phrase role="special">&gt;</phrase> <phrase role="identifier">pv</phrase><phrase role="special">(</phrase><phrase role="identifier">Circle</phrase><phrase role="special">(</phrase><phrase role="number">8</phrase><phrase role="special">));</phrase>
<phrase role="identifier">foo</phrase><phrase role="special">(*</phrase><phrase role="identifier">pv</phrase><phrase role="special">);</phrase>
<phrase role="keyword">double</phrase> <phrase role="identifier">area</phrase> <phrase role="special">=</phrase> <phrase role="identifier">pv</phrase><phrase role="special">-&gt;</phrase><phrase role="identifier">Area</phrase><phrase role="special">();</phrase>

<phrase role="comment">// mis-use (pointer stability not guaranteed)</phrase>
<phrase role="identifier">polymorphic_value</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">Shape</phrase><phrase role="special">&gt;</phrase> <phrase role="identifier">pv</phrase><phrase role="special">(</phrase><phrase role="identifier">Circle</phrase><phrase role="special">(</phrase><phrase role="number">8</phrase><phrase role="special">));</phrase>
<phrase role="identifier">Shape</phrase><phrase role="special">*</phrase> <phrase role="identifier">s</phrase> <phrase role="special">=</phrase> <phrase role="identifier">pv</phrase><phrase role="special">.</phrase><phrase role="keyword">operator</phrase><phrase role="special">-&gt;();</phrase>
<phrase role="identifier">foo</phrase><phrase role="special">(*</phrase><phrase role="identifier">pv</phrase><phrase role="special">);</phrase>
<phrase role="keyword">double</phrase> <phrase role="identifier">area</phrase> <phrase role="special">=</phrase> <phrase role="identifier">s</phrase><phrase role="special">-&gt;</phrase><phrase role="identifier">Area</phrase><phrase role="special">();</phrase>
</programlisting>
      <para>
        The unnatural looking code that one is required to write to cache a pointer
        to a <code><phrase role="identifier">polymorphic_value</phrase></code>'s
        managed object should be a suitable deterrent.
      </para>
    </section>
    <section id="boost_polymorphicvalue__proposed_.tutorial.when_to_use__polymorphic_value_">
      <title><link linkend="boost_polymorphicvalue__proposed_.tutorial.when_to_use__polymorphic_value_">When
      to use <code><phrase role="identifier">polymorphic_value</phrase></code></link></title>
      <para>
        <code><phrase role="identifier">polymorphic_value</phrase></code> is designed
        to be used in polymorphic component-based designs where the set of possible
        component types is open to extension (open-set polymorphism).
      </para>
      <para>
        <code><phrase role="identifier">polymorphic_value</phrase></code> introduces
        a virtual function call into copy construction and memory indirection into
        member function invocation. C++ advocates only paying for what you use so
        we would advocate avoiding the unnecessary use of <code><phrase role="identifier">polymorphic_value</phrase></code>.
      </para>
      <para>
        If a component design does not require polymorphic components then storing
        components by value may be a better choice than using <code><phrase role="identifier">polymorphic_value</phrase></code>.
      </para>
      <para>
        If a component design does not require mutable components then storing components
        by <code><phrase role="identifier">std</phrase><phrase role="special">::</phrase><phrase
        role="identifier">shared_ptr</phrase><phrase role="special">&lt;</phrase><phrase
        role="keyword">const</phrase> <phrase role="identifier">T</phrase><phrase
        role="special">&gt;</phrase></code> may be a better choice than using <code><phrase
        role="identifier">polymorphic_value</phrase></code> (Note the <code><phrase
        role="keyword">const</phrase></code>).
      </para>
      <para>
        If a component design has component sub-types chosen from a known set of
        sub-types, then an <code><phrase role="identifier">std</phrase><phrase role="special">::</phrase><phrase
        role="identifier">variant</phrase><phrase role="special">&lt;</phrase><phrase
        role="identifier">A</phrase><phrase role="special">,</phrase><phrase role="identifier">B</phrase><phrase
        role="special">,</phrase><phrase role="identifier">C</phrase><phrase role="special">&gt;</phrase></code>
        may be a better choice than using <code><phrase role="identifier">polymorphic_value</phrase></code>.
      </para>
      <para>
        If a component design requires an open or extensible set of component sub-types,
        and mutability of components then <code><phrase role="identifier">polymorphic_value</phrase></code>
        may be a good choice.
      </para>
    </section>
    <section id="boost_polymorphicvalue__proposed_.tutorial.custom_copiers_and_deleters">
      <title><link linkend="boost_polymorphicvalue__proposed_.tutorial.custom_copiers_and_deleters">Custom
      copiers and deleters</link></title>
      <para>
        <code><phrase role="identifier">polymorphic_value</phrase></code> supports
        the use of custom copiers and deleters through a raw-pointer constructor
        where the <code><phrase role="identifier">polymorphic_value</phrase></code>
        takes ownership of the pointer.
      </para>
<programlisting><phrase role="keyword">template</phrase> <phrase role="special">&lt;</phrase><phrase role="keyword">class</phrase> <phrase role="identifier">U</phrase><phrase role="special">,</phrase>
          <phrase role="keyword">class</phrase> <phrase role="identifier">C</phrase><phrase role="special">=</phrase><phrase role="identifier">boost</phrase><phrase role="special">::</phrase><phrase role="identifier">default_copy</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">U</phrase><phrase role="special">&gt;,</phrase>
          <phrase role="keyword">class</phrase> <phrase role="identifier">D</phrase><phrase role="special">=</phrase><phrase role="identifier">default_delete</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">U</phrase><phrase role="special">&gt;&gt;</phrase>
          <phrase role="comment">// requires U* is convertible to T*</phrase>
<phrase role="identifier">polymorphic_value</phrase><phrase role="special">(</phrase><phrase role="identifier">U</phrase><phrase role="special">*</phrase> <phrase role="identifier">u</phrase><phrase role="special">,</phrase> <phrase role="identifier">C</phrase> <phrase role="identifier">c</phrase> <phrase role="special">=</phrase> <phrase role="identifier">C</phrase><phrase role="special">{},</phrase> <phrase role="identifier">D</phrase> <phrase role="identifier">d</phrase> <phrase role="special">=</phrase> <phrase role="identifier">D</phrase><phrase role="special">{});</phrase>
</programlisting>
      <para>
        This constructor is intended for situations where the copy constructor of
        <code><phrase role="identifier">U</phrase></code> and <code><phrase role="keyword">delete</phrase>
        <phrase role="identifier">U</phrase></code> are not appropriate choices.
      </para>
      <para>
        When objects are created from a C-API there may be API-provided methods to
        create, copy and delete objects. The pointer-constructor of polymorphic_value
        would enable use of such objects.
      </para>
<programlisting><phrase role="comment">// C-API pointer</phrase>
<phrase role="keyword">struct</phrase> <phrase role="identifier">c_api_t</phrase><phrase role="special">;</phrase>
<phrase role="keyword">using</phrase> <phrase role="identifier">c_api_p</phrase> <phrase role="special">=</phrase> <phrase role="identifier">c_api_t</phrase><phrase role="special">*;</phrase>

<phrase role="comment">// C-API functions</phrase>
<phrase role="identifier">c_api_p</phrase> <phrase role="identifier">c_api_object_create</phrase><phrase role="special">(</phrase><phrase role="keyword">int</phrase> <phrase role="identifier">arg</phrase><phrase role="special">);</phrase>
<phrase role="identifier">c_api_p</phrase> <phrase role="identifier">c_api_object_copy</phrase><phrase role="special">(</phrase><phrase role="identifier">c_api_p</phrase> <phrase role="identifier">p</phrase><phrase role="special">);</phrase>
<phrase role="keyword">void</phrase> <phrase role="identifier">c_api_object_dispose</phrase><phrase role="special">(</phrase><phrase role="identifier">c_api_p</phrase> <phrase role="identifier">p</phrase><phrase role="special">);</phrase>

<phrase role="identifier">polymorphic_value</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">c_api_t</phrase><phrase role="special">&gt;</phrase> <phrase role="identifier">pv</phrase><phrase role="special">(</phrase>
  <phrase role="identifier">c_api_object_create</phrase><phrase role="special">(</phrase><phrase role="number">42</phrase><phrase role="special">),</phrase>
  <phrase role="special">[](</phrase><phrase role="keyword">const</phrase> <phrase role="identifier">c_api_t</phrase><phrase role="special">&amp;</phrase> <phrase role="identifier">o</phrase><phrase role="special">)</phrase> <phrase role="special">{</phrase> <phrase role="keyword">return</phrase> <phrase role="identifier">c_api_object_copy</phrase><phrase role="special">(&amp;</phrase><phrase role="identifier">o</phrase><phrase role="special">);},</phrase>
  <phrase role="special">[](</phrase><phrase role="keyword">const</phrase> <phrase role="identifier">c_api_p</phrase><phrase role="special">*</phrase> <phrase role="identifier">p</phrase><phrase role="special">)</phrase> <phrase role="special">{</phrase> <phrase role="identifier">c_api_object_dispose</phrase><phrase role="special">(</phrase><phrase role="identifier">p</phrase><phrase role="special">);</phrase> <phrase role="special">}</phrase>
<phrase role="special">);</phrase>
</programlisting>
      <bridgehead renderas="sect4" id="boost_polymorphicvalue__proposed_.tutorial.custom_copiers_and_deleters.h0">
        <phrase id="boost_polymorphicvalue__proposed_.tutorial.custom_copiers_and_deleters.migrating_from_a__code__phrase_role__identifier__clone__phrase___code__method"/><link
        linkend="boost_polymorphicvalue__proposed_.tutorial.custom_copiers_and_deleters.migrating_from_a__code__phrase_role__identifier__clone__phrase___code__method">Migrating
        from a <code><phrase role="identifier">Clone</phrase></code> method</link>
      </bridgehead>
      <para>
        The pointer constructor can be used to migrate from a class heirarchy with
        a <code><phrase role="identifier">Clone</phrase></code> method.
      </para>
      <para>
        Suppose there is a base class that inherits from the mixin <code><phrase
        role="identifier">Cloneable</phrase></code>:
      </para>
<programlisting><phrase role="keyword">template</phrase> <phrase role="special">&lt;</phrase><phrase role="keyword">class</phrase> <phrase role="identifier">T</phrase><phrase role="special">&gt;</phrase>
<phrase role="keyword">struct</phrase> <phrase role="identifier">Cloneable</phrase> <phrase role="special">{</phrase>
  <phrase role="keyword">virtual</phrase> <phrase role="special">~</phrase><phrase role="identifier">Cloneable</phrase><phrase role="special">()</phrase> <phrase role="special">=</phrase> <phrase role="keyword">default</phrase><phrase role="special">;</phrase>
  <phrase role="keyword">virtual</phrase> <phrase role="identifier">std</phrase><phrase role="special">::</phrase><phrase role="identifier">unique_ptr</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">T</phrase><phrase role="special">&gt;</phrase> <phrase role="identifier">Clone</phrase><phrase role="special">()</phrase> <phrase role="keyword">const</phrase> <phrase role="special">=</phrase> <phrase role="number">0</phrase><phrase role="special">;</phrase>
<phrase role="special">};</phrase>

<phrase role="keyword">class</phrase> <phrase role="identifier">Shape</phrase> <phrase role="special">:</phrase> <phrase role="keyword">public</phrase> <phrase role="identifier">Cloneable</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">Shape</phrase><phrase role="special">&gt;</phrase> <phrase role="special">{</phrase>
 <phrase role="keyword">public</phrase><phrase role="special">:</phrase>
  <phrase role="keyword">virtual</phrase> <phrase role="special">~</phrase><phrase role="identifier">Shape</phrase><phrase role="special">()</phrase> <phrase role="special">=</phrase> <phrase role="keyword">default</phrase><phrase role="special">;</phrase>
  <phrase role="comment">// ... </phrase>
<phrase role="special">};</phrase>
</programlisting>
      <para>
        We can use the pointer constructor to ensure that <code><phrase role="identifier">polymorphic_value</phrase></code>
        calls the clone method.
      </para>
<programlisting><phrase role="identifier">std</phrase><phrase role="special">::</phrase><phrase role="identifier">unique_ptr</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">Shape</phrase><phrase role="special">&gt;</phrase> <phrase role="identifier">s</phrase> <phrase role="special">=</phrase> <phrase role="identifier">shape_factory</phrase><phrase role="special">(</phrase><phrase role="string">&quot;Ellipse&quot;</phrase><phrase role="special">);</phrase>
<phrase role="identifier">polymorphic_value</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">Shape</phrase><phrase role="special">&gt;</phrase> <phrase role="identifier">pv</phrase><phrase role="special">(</phrase>
  <phrase role="identifier">s</phrase><phrase role="special">.</phrase><phrase role="identifier">release</phrase><phrase role="special">(),</phrase>
  <phrase role="special">[](</phrase><phrase role="keyword">const</phrase> <phrase role="identifier">Shape</phrase><phrase role="special">&amp;</phrase> <phrase role="identifier">o</phrase><phrase role="special">)</phrase> <phrase role="special">{</phrase> <phrase role="keyword">return</phrase> <phrase role="identifier">o</phrase><phrase role="special">.</phrase><phrase role="identifier">Clone</phrase><phrase role="special">().</phrase><phrase role="identifier">release</phrase><phrase role="special">();</phrase> <phrase role="special">},</phrase>
<phrase role="special">);</phrase>
</programlisting>
      <para>
        Once <code><phrase role="identifier">Clone</phrase></code> is only used within
        <code><phrase role="identifier">polymorphic_value</phrase></code> we can
        modify <code><phrase role="identifier">Shape</phrase></code> to make it copyable.
      </para>
<programlisting><phrase role="keyword">class</phrase> <phrase role="identifier">Shape</phrase> <phrase role="special">{</phrase>
 <phrase role="keyword">public</phrase><phrase role="special">:</phrase>
  <phrase role="keyword">virtual</phrase> <phrase role="special">~</phrase><phrase role="identifier">Shape</phrase><phrase role="special">()</phrase> <phrase role="special">=</phrase> <phrase role="keyword">default</phrase><phrase role="special">;</phrase>
  <phrase role="identifier">Shape</phrase><phrase role="special">(</phrase><phrase role="keyword">const</phrase> <phrase role="identifier">Shape</phrase><phrase role="special">&amp;)</phrase> <phrase role="special">=</phrase> <phrase role="keyword">default</phrase><phrase role="special">;</phrase>
  <phrase role="identifier">Shape</phrase><phrase role="special">(</phrase><phrase role="identifier">Shape</phrase><phrase role="special">&amp;&amp;)</phrase> <phrase role="special">=</phrase> <phrase role="keyword">default</phrase><phrase role="special">;</phrase>
  <phrase role="identifier">Shape</phrase><phrase role="special">&amp;</phrase> <phrase role="keyword">operator</phrase><phrase role="special">=(</phrase><phrase role="keyword">const</phrase> <phrase role="identifier">Shape</phrase><phrase role="special">&amp;)</phrase> <phrase role="special">=</phrase> <phrase role="keyword">default</phrase><phrase role="special">;</phrase>
  <phrase role="identifier">Shape</phrase><phrase role="special">&amp;</phrase> <phrase role="keyword">operator</phrase><phrase role="special">=(</phrase><phrase role="identifier">Shape</phrase><phrase role="special">&amp;&amp;)</phrase> <phrase role="special">=</phrase> <phrase role="keyword">default</phrase><phrase role="special">;</phrase>
  <phrase role="comment">// ... </phrase>
<phrase role="special">};</phrase>

<phrase role="identifier">std</phrase><phrase role="special">::</phrase><phrase role="identifier">unique_ptr</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">Shape</phrase><phrase role="special">&gt;</phrase> <phrase role="identifier">s</phrase> <phrase role="special">=</phrase> <phrase role="identifier">shape_factory</phrase><phrase role="special">(</phrase><phrase role="string">&quot;Ellipse&quot;</phrase><phrase role="special">);</phrase>
<phrase role="identifier">polymorphic_value</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">Shape</phrase><phrase role="special">&gt;</phrase> <phrase role="identifier">pv</phrase><phrase role="special">(</phrase><phrase role="identifier">s</phrase><phrase role="special">.</phrase><phrase role="identifier">release</phrase><phrase role="special">());</phrase>
</programlisting>
    </section>
  </section>
  <section id="boost_polymorphicvalue__proposed_.type_requirements">
    <title><link linkend="boost_polymorphicvalue__proposed_.type_requirements">Type
    Requirements</link></title>
    <para>
      For:
    </para>
<programlisting><phrase role="keyword">class</phrase> <phrase role="identifier">MyClass</phrase> <phrase role="special">{</phrase>
  <phrase role="identifier">boost</phrase><phrase role="special">::</phrase><phrase role="identifier">polymorphic_value</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">T</phrase><phrase role="special">&gt;</phrase> <phrase role="identifier">component_</phrase><phrase role="special">;</phrase>
<phrase role="special">};</phrase>
</programlisting>
    <itemizedlist>
      <listitem>
        <simpara>
          <code><phrase role="identifier">T</phrase></code> must be a non-union class
          type.
        </simpara>
      </listitem>
      <listitem>
        <simpara>
          <code><phrase role="identifier">T</phrase></code> can be an incomplete
          type.
        </simpara>
      </listitem>
    </itemizedlist>
    <para>
      For:
    </para>
<programlisting><phrase role="identifier">U</phrase> <phrase role="identifier">u</phrase><phrase role="special">;</phrase>
<phrase role="identifier">boost</phrase><phrase role="special">::</phrase><phrase role="identifier">polymorphic_value</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">T</phrase><phrase role="special">&gt;</phrase> <phrase role="identifier">pv</phrase><phrase role="special">(</phrase><phrase role="identifier">u</phrase><phrase role="special">);</phrase>
</programlisting>
    <para>
      and:
    </para>
<programlisting><phrase role="identifier">boost</phrase><phrase role="special">::</phrase><phrase role="identifier">polymorphic_value</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">T</phrase><phrase role="special">&gt;</phrase> <phrase role="identifier">pv</phrase><phrase role="special">(</phrase><phrase role="identifier">U</phrase><phrase role="special">{});</phrase>
</programlisting>
    <itemizedlist>
      <listitem>
        <simpara>
          <code><phrase role="identifier">U</phrase><phrase role="special">*</phrase></code>
          must be convertible to <code><phrase role="identifier">T</phrase><phrase
          role="special">*</phrase></code>.
        </simpara>
      </listitem>
      <listitem>
        <simpara>
          <code><phrase role="identifier">U</phrase></code> must be <emphasis>CopyConstructible</emphasis>.
        </simpara>
      </listitem>
      <listitem>
        <simpara>
          <code><phrase role="identifier">U</phrase></code> must be nothrow destructible.
        </simpara>
      </listitem>
    </itemizedlist>
    <para>
      For:
    </para>
<programlisting><phrase role="identifier">U</phrase><phrase role="special">*</phrase> <phrase role="identifier">pu</phrase> <phrase role="special">=</phrase> <phrase role="identifier">make_some_u</phrase><phrase role="special">();</phrase>
<phrase role="identifier">Copier</phrase> <phrase role="identifier">c</phrase><phrase role="special">;</phrase>
<phrase role="identifier">Deleter</phrase> <phrase role="identifier">d</phrase><phrase role="special">;</phrase>
<phrase role="identifier">boost</phrase><phrase role="special">::</phrase><phrase role="identifier">polymorphic_value</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">T</phrase><phrase role="special">&gt;(</phrase><phrase role="identifier">pu</phrase><phrase role="special">,</phrase> <phrase role="identifier">c</phrase><phrase role="special">,</phrase> <phrase role="identifier">d</phrase><phrase role="special">);</phrase>
</programlisting>
    <itemizedlist>
      <listitem>
        <simpara>
          <code><phrase role="identifier">U</phrase><phrase role="special">*</phrase></code>
          must be convertible to <code><phrase role="identifier">T</phrase><phrase
          role="special">*</phrase></code>.
        </simpara>
      </listitem>
      <listitem>
        <simpara>
          <code><phrase role="identifier">c</phrase><phrase role="special">(*</phrase><phrase
          role="identifier">u</phrase><phrase role="special">)</phrase></code> must
          be well-formed and must return an object that can be converted to, and
          stored as a <code><phrase role="identifier">T</phrase><phrase role="special">*</phrase></code>.
        </simpara>
      </listitem>
      <listitem>
        <simpara>
          <code><phrase role="identifier">d</phrase><phrase role="special">(</phrase><phrase
          role="identifier">u</phrase><phrase role="special">)</phrase></code> must
          be well-formed and must not throw an exception.
        </simpara>
      </listitem>
    </itemizedlist>
  </section>
  <xi:include href="../../../polymorphic_value_reference.xml" />
</library>
